from utils.support import get_logger, pkl_dump, jsn_dump

import os
from pathlib import Path
import pandas as pd
import cv2
import numpy as np
from sklearn.model_selection import StratifiedKFold


def gen_dataset_df(data_path_):
    """Collect table with full paths to image files, their sizes in bytes
    and images themselves as numpy.arrays.

    Args:
        data_path_ (str): path to the folder with the images.

    Returns:
        dataset_df_ (pandas.DataFrame): DataFrame with 3 columns: img_path, size, img.
    """
    dataset_df_ = pd.DataFrame()

    for dir_name, _, file_names in os.walk(data_path_):
        for filename in file_names:
            img_path = Path(os.path.join(dir_name, filename))
            size_ = img_path.stat().st_size
            dataset_df_ = dataset_df_.append({
                "img_path": img_path,
                "size": size_,
                "img": cv2.imread(str(img_path), cv2.IMREAD_GRAYSCALE),
            }, ignore_index=True)

    dataset_df_["size"] = dataset_df_["size"].astype(int)

    return dataset_df_


def gen_identity_df(provided_dataset_df_, cew_dataset_df_):
    """Checks if images from internal_df precise in external_df.

    Args:
        provided_dataset_df_ (pandas.DataFrame): dataset_df generated by gen_dataset_df function.
        cew_dataset_df_ (pandas.DataFrame): dataset_df generated by gen_dataset_df function.

    Returns:
        identity_df_ (pandas.DataFrame): dataframe with 2 columns:
            cew_img - contains a path to an image from external_df_
            provided_img - contains a path to an image from internal_df_
                if it precise there, otherwise None.
    """

    identity_df_ = pd.DataFrame()
    for size in cew_dataset_df_["size"].unique():
        ext_df = cew_dataset_df_[cew_dataset_df_["size"] == size]
        int_df = provided_dataset_df_[provided_dataset_df_["size"] == size]

        for _, ext_row in ext_df.iterrows():
            pair = None
            for _, int_row in int_df.iterrows():
                if (ext_row["img"] == int_row["img"]).all():
                    pair = int_row["img_path"]
                    break

            identity_df_ = identity_df_.append({
                "cew_img": ext_row["img_path"],
                "provided_img": pair
            }, ignore_index=True)
    return identity_df_


def main(config, logger):
    pth = Path(config["output"]) / "crossval_split"
    os.makedirs(pth, exist_ok=True)
    jsn_dump(config, pth / "config.jsn")
    # CHECK IDENTITY
    cew_dataset_df = gen_dataset_df(config["cew_path"])
    logger.info("CEW dataset_df generated.")

    provided_dataset_df = gen_dataset_df(config["provided_path"])
    logger.info("Provided dataset_df generated.")

    identity_df = gen_identity_df(provided_dataset_df, cew_dataset_df)
    logger.info("Identity_df generated.")

    # Collect labels into identity_df
    identity_df["label"] = identity_df["cew_img"].apply(lambda x: x.parent.name).map({
        "openLeftEyes": 1,
        "openRightEyes": 1,
        "closedLeftEyes": 0,
        "closedRightEyes": 0,
    })
    assert identity_df["label"].isnull().sum() == 0, "Identity_df has NaN in labels."

    # saving identity_df
    pkl_dump(identity_df, pth / "identity_df.pkl")

    # If the number of provided images with a pair from CEW images
    # is equal to the number of provided images, then datasets are identical
    if not (~identity_df["provided_img"].isnull()).sum() == len(provided_dataset_df):
        logger.info("Datasets are NOT identical!")
    else:
        logger.info("Datasets are identical!")

        # CROSS_VALIDATION SPLIT

        # Hidden Images
        #   Take N images, which precise in the provided dataset,
        #   where N - is the difference between number of images in CEW dataset and the provided dataset.
        hidden_images = np.random.choice(
            a=identity_df[~identity_df["provided_img"].isnull()]["cew_img"].values,
            size=identity_df["provided_img"].isnull().sum(),
            replace=False
        )
        crossval_dct = {
            "hidden": identity_df[identity_df["cew_img"].isin(hidden_images)]
        }
        identity_df = identity_df[~identity_df["cew_img"].isin(hidden_images)]

        # Folds
        skf = StratifiedKFold(n_splits=config["folds"], shuffle=True, random_state=config["seed"])
        for fold, (train_index, valid_index) in enumerate(skf.split(identity_df, identity_df["label"]), start=1):
            crossval_dct[fold] = {
                "train": identity_df.iloc[train_index],
                "valid": identity_df.iloc[valid_index],
            }
        logger.info("Cross-validation split completed.")

        # saving crossval_dct
        pkl_dump(crossval_dct, pth / "crossval_dct.pkl")


if __name__ == "__main__":
    cfg = {
        "cew_path": "../data/dataset_B_Eye_Images/",
        "provided_path": "../data/EyesDataset",
        "output": "../output",
        "folds": 5,
        "seed": 0
    }

    main(cfg, get_logger("datasets_identity_check"))
